document.addEventListener('DOMContentLoaded', () => {
  const tableBody = document.getElementById('produitsTableBody');
  const paginationEl = document.getElementById('pagination');
  const infoPagination = document.getElementById('infoPagination');
  const loadingEl = document.getElementById('topLoad');
  const searchInput = document.getElementById('searchInput');
  const rowsPerPageEl = document.getElementById('rowsPerPage');
  const mergeModeEl = document.getElementById('mergeMode');
  const btnRefresh = document.getElementById('btnRefresh');
  const btnExcel = document.getElementById('btnExcel');

  let currentPage = 1;
  let totalPages = 1;
  let allProduits = [];

  // ============================
  // Fetch produits
  // ============================
  async function fetchProducts(page = 1, limit = 50, search = '') {
    try {
      loadingEl.style.display = 'block';
      const res = await fetch(`/api/ProduitsTotal?page=${page}&limit=${limit}&search=${encodeURIComponent(search)}`);
      if (!res.ok) throw new Error('Erreur serveur');
      const data = await res.json();
      allProduits = data.produits || [];
      return data;
    } finally {
      loadingEl.style.display = 'none';
    }
  }

  // ============================
  // Build merge key
  // ============================
  function buildMergeKey(p) {
    if (!mergeModeEl) return `${p.anpf}-${p.adresse}-${p.calcul}-${Math.random()}`;
    switch (mergeModeEl.value) {
      case 'anpf': return p.anpf || Math.random();
      case 'adresse': return p.adresse || Math.random();
      case 'anpf-adresse': return `${p.anpf || ''}-${p.adresse || ''}`;
      case 'all': return `${p.anpf || ''}-${p.adresse || ''}-${p.calcul || ''}`;
      default: return `${p.anpf}-${p.adresse}-${p.calcul}-${Math.random()}`;
    }
  }

  // ============================
  // Merge produits
  // ============================
  function mergeProduits(produits) {
    const map = new Map();
    produits.forEach(p => {
      const key = buildMergeKey(p);
      if (!map.has(key)) {
        map.set(key, { ...p, qteInven: Number(p.qteInven) || 0, stock: Number(p.stock) || 0, mergedCount: 1 });
      } else {
        const item = map.get(key);
        item.qteInven += Number(p.qteInven) || 0;
        item.mergedCount += 1;
      }
    });
    return Array.from(map.values());
  }

  // ============================
  // Filter produits
  // ============================
  function filterProduits(produits, query) {
    if (!query) return produits;
    const q = query.toLowerCase();
    return produits.filter(p =>
      (p.gencode && p.gencode.toLowerCase().includes(q)) ||
      (p.anpf && p.anpf.toLowerCase().includes(q)) ||
      (p.adresse && p.adresse.toLowerCase().includes(q)) ||
      (p.calcul && p.calcul.toLowerCase().includes(q))
    );
  }

  // ============================
  // Render table
  // ============================
  async function renderTable(page = 1) {
    const limit = parseInt(rowsPerPageEl?.value || 50);
    const search = searchInput?.value.trim() || '';

    const data = await fetchProducts(page, limit, search);
    currentPage = page;

    let produitsToDisplay = allProduits;
    produitsToDisplay = filterProduits(produitsToDisplay, search);

    if (mergeModeEl && mergeModeEl.value !== 'none') {
      produitsToDisplay = mergeProduits(produitsToDisplay);
    }

    tableBody.innerHTML = produitsToDisplay.map(p => {
      const stock = Number(p.stock) || 0;
      const qteInven = Number(p.qteInven) || 0;
      const ecart = qteInven - stock;
      const bgColor = ecart > 0 ? 'background-color:#198754;color:white;' :
                      ecart < 0 ? 'background-color:#dc3545;color:white;' :
                      'background-color:#f8f9fa;';

      const libelleDisplay = p.mergedCount > 1 ? `${p.libelle} (${p.mergedCount} produits)` : p.libelle;

      return `
        <tr>
          <td>${libelleDisplay || ''}</td>
          <td>${p.gencode || ''}</td>
          <td>${p.anpf || ''}</td>
          <td>${p.fournisseur || ''}</td>
          <td>${stock}</td>
          <td>${qteInven}</td>
          <td style="${bgColor}">${ecart}</td>
          <td>${p.adresse || ''}</td>
          <td>${p.nameVendeur || ''}</td>
          <td>${p.calcul || ''}</td>
          <td>${p.createdAt ? new Date(p.createdAt).toLocaleString('fr-FR') : ''}</td>
        </tr>
      `;
    }).join('');

    renderPagination(produitsToDisplay.length, limit);
  }

  // ============================
  // Render pagination
  // ============================
  function renderPagination(totalItems, limit = 50) {
    const maxButtons = 5;
    totalPages = Math.ceil(totalItems / limit);
    let startPage = Math.max(1, currentPage - Math.floor(maxButtons / 2));
    let endPage = Math.min(totalPages, startPage + maxButtons - 1);
    if (endPage - startPage + 1 < maxButtons) startPage = Math.max(1, endPage - maxButtons + 1);

    paginationEl.innerHTML = '';

    const createLi = (text, pageNum, disabled = false, active = false) => {
      const li = document.createElement('li');
      li.className = `page-item ${disabled ? 'disabled' : ''} ${active ? 'active' : ''}`;
      li.innerHTML = `<a class="page-link" href="#">${text}</a>`;
      if (!disabled && !active) li.addEventListener('click', e => { e.preventDefault(); renderTable(pageNum); });
      return li;
    };

    paginationEl.appendChild(createLi('‹ Précédent', currentPage - 1, currentPage === 1));
    for (let i = startPage; i <= endPage; i++) paginationEl.appendChild(createLi(i, i, false, i === currentPage));
    paginationEl.appendChild(createLi('Suivant ›', currentPage + 1, currentPage === totalPages));

    infoPagination.textContent = `Page ${currentPage} sur ${totalPages} - Total: ${totalItems} produits`;
  }

  // ============================
  // Event listeners
  // ============================
  searchInput?.addEventListener('input', () => renderTable(1));
  rowsPerPageEl?.addEventListener('change', () => renderTable(1));
  mergeModeEl?.addEventListener('change', () => renderTable(1));
  btnRefresh?.addEventListener('click', () => renderTable(currentPage));
  btnExcel?.addEventListener('click', async () => {
    try {
      loadingEl.textContent = '⏳ Génération du fichier Excel...';
      loadingEl.style.display = 'block';
      const res = await fetch('/api/exportExcel');
      if (!res.ok) throw new Error('Erreur serveur');
      const blob = await res.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'Inventaire_Complet.xlsx';
      document.body.appendChild(a);
      a.click();
      a.remove();
      window.URL.revokeObjectURL(url);
      bootstrap.Toast.getOrCreateInstance(document.getElementById('excelToast')).show();
    } catch (err) {
      console.error(err);
      alert('❌ Erreur lors de l’export Excel');
    } finally {
      loadingEl.style.display = 'none';
      loadingEl.textContent = '⏳ Chargement des données...';
    }
  });

  // ============================
  // Initial render
  // ============================
  renderTable(1);
});